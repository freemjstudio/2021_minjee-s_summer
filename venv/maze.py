# 먼저 미로를 2차원 배열로 표시한다
# 최단 경로 찾기.. 스택? 큐 ? 역시 스택인가..
# 푸시 팝 이용하면 되나 ? 간길이면 다시 돌아오고 아니면 확인하기

maze[10][10] = [
[1,1,1,1,1,1,1,1,1 ,1],
[1 ,0, 0, 1, 0, 0, 0, 0, 0, 1],
[1, 0, 0, 1, 1, 1, 0, 0, 0, 1],
[1 ,0 ,0 ,0 ,0 ,0 ,0 ,1 ,0 ,1],
[1 ,0 ,0 ,0 ,0 ,0 ,0, 1, 0, 1],
[1 ,0 ,0 ,0 ,0 ,1 ,0 ,1 ,0 ,1],
[1 ,0 ,0 ,0 ,0 ,1 ,2 ,1 ,0 ,1],
[1 ,0 ,0 ,0 ,0 ,1 ,0 ,0, 0, 1],
[1 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,1],
[1 ,1 ,1 ,1 ,1 ,1 ,1 ,1 ,1 ,1]
]


# 반드시 오른쪽 또는 아래쪽으로 움직인다.



#먹이가 2일때 무조건 지나야 한다 !!!

def check(): # 오른쪽 칸이나 아래쪽 칸이 값이 0 이면 push 하는 함수
    if maze[i][j+1] == 0:
        maze[i][j] = maze[i][j+1]
    elif maze


    return

def shortest_route():
    start = maze[2][2]
    end = maze[9][9]
    curr = maze[i][j]
    route = [] # 경로를 표시하는 스

    start = 1 # start 지점 방문한걸로 표시한다. 택

    while(curr == 2):
        if (curr == 0):
            curr =
        elif (curr == 1):
            # 그전 좌표로 되돌아 간다.


    return maze